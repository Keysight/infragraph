/* InfraGraph 0.1.0
 * ### Overview
 * InfraGraph or `infrastructure graph` defines a model-driven, vendor-neutral, standard
 * interface for capturing a system of systems suitable for use in co-designing AI/HPC
 * solutions.
 * 
 * This model allows for defining physical infrastructure as a logical system of systems
 * using graph like terminology.
 * In addition to defining a logical graph, an unlimited number of different physical
 * characteristics
 * can be associated with logical endpoints.
 * 
 * ### Graph Terminology
 * - `vertex` is the fundamental unit or entity within a graph; represented as a point.
 * In this model it is one of the following:
 * - a combination of a component name and a 0 based index such as `asic.0`
 * - a device instance name, a 0 based index, an external component and a 0 based
 * index such as `host.0.nic.0`.
 * - `edge` is a connection between two vertices in a graph. It can be a connection
 * between two component instances or two device instances. The connection also includes
 * a logical label for identifying the type of link between the two vertexes, for example
 * `asic.0`.`ic`.`port.0`
 * - `path` is a sequence of connections that allows for traversal through the graph
 * 
 * ### Contributions
 * Contributions to the API and models schema can be made in the following ways:
 * - [open an issue](https://github.com/keysight/infragraph/issues) in the models repository
 * - [fork the models repository](https://github.com/keysight/infragraph) and submit
 * a PR
 * License: MIT */

syntax = "proto3";

package infragraph;

option go_package = "./infragraph;infragraph";

import "google/protobuf/descriptor.proto";
import "google/protobuf/empty.proto";

// Description missing in models
message Infrastructure {

  // The name of the infrastructure being described.
  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  optional string name = 1;

  // A description of the infrastructure being described.
  optional string description = 2;

  // An array of the devices and their components present in the infrastructure connections.
  repeated Device devices = 3;

  // An inventory of the links that are part of the infrastructure connections property.
  repeated Link links = 4;

  // These edges are used to connect device components to other device components
  // forming a fully qualified graph based on the contents of the Infrastructure object.
  repeated InfrastructureEdge edges = 5;

  // Annotations are meant to extend the current schema with any kind of additional data
  // such as
  // static, dynamic, logical and physical information (e.g., configuration, routing etc).
  repeated Annotation annotations = 6;
}

// A subgraph container for a device and its components, links and connections.
// The connections form a subgraph.
// 
// e.g., Describe a switch device in detail.
// 
// At a simple level a switch has an asic and ports.
// The asic can be made up of of core, mem, crypt, alu, dsp, pll, ics (interconnect
// structure), iop (i/o pad).
// The Device can capture just the asic and ports connected by an integrated circuit
// or
// the asic can be broken down into more discrete components.
// 
// Simple Approach: asic, cpu, port, ic
// Detailed Approach: cpu, core, mem, alu, pll, iop, ic, port
// 
// name: arista
// description: |-
// The Arista is a network switch platform,
// commonly equipped with 48 x 1G Ethernet ports and 4 x 10G uplink ports,
// typically implemented using a Jericho2 ASIC
// components: [core, mem, crypt, alu, iop, port]
// links: [ics]
// connections:
// - core.0.ics.mem.0
// - core.0.ics.crypt.0
// - core.0.ics.alu.0
// - core.0.ics.iop.0
// - core.0.ics.iop.47
// - iop.0.ics.port.0
// ...
// - iop.47.ics.port.47
// 
// - to traverse from the core asic to a port, multiple connections are used to form
// a path
// - core.0.ics.iop.0.ics.port.0
message Device {

  // The name of the device being described.
  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  optional string name = 1;

  // A description of the device.
  // This will not be used in Infrastructure.connections.
  optional string description = 2;

  // The number of instances of this device if not contained in another device.
  // If the device is contained within another device the count is multiplied
  // by the containing device count.
  optional float count = 3;

  // Description missing in models
  repeated Component components = 4;

  // All the links that make up this device.
  repeated Link links = 5;

  // An array of edges that are used to produce a device graph.
  // These are used to connect components to each other or components
  // to other device components (composability).
  // The generated graph edges will be fully qualified using the count property
  // of the device and component and slice notation of each endpoint in the edge object.
  repeated DeviceEdge edges = 6;
}

// A container for describing a component.
// A Component is contained in a Device.
message Component {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  optional string name = 1;

  // A description of the component.
  optional string description = 2;

  message Type {
    enum Enum {
      unspecified = 0;
      custom = 1;
      cpu = 2;
      npu = 3;
      nic = 4;
      memory = 5;
      port = 6;
    }
  }
  // Type of component.
  // Any component not listed as an enum can be defined using the custom type.
  // required = true
  optional Type.Enum type = 3;

  // Indicates whether this component is an ingress/egress component in a device.
  // Only those components that have this property set to true can be used in an infrastructure
  // connection.
  // default = False
  optional bool external = 4;
}

// A container for specific Link physical Properties.
message LinkPhysicalBandwidth {

  message Choice {
    enum Enum {
      unspecified = 0;
      gigabits_per_second = 1;
      gigabytes_per_second = 2;
      gigatransfers_per_second = 3;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Gigabits per second.
  optional float gigabits_per_second = 2;

  // Gigabytes per second.
  optional float gigabytes_per_second = 3;

  // Gigatrasfers per second.
  optional float gigatransfers_per_second = 4;
}

// A container for specific Link latency properties.
message LinkPhysicalLatency {

  message Choice {
    enum Enum {
      unspecified = 0;
      ms = 1;
      us = 2;
      ns = 3;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Latency in milliseconds
  optional float ms = 2;

  // Latency in microseconds.
  optional float us = 3;

  // Latency in nanoseconds.
  optional float ns = 4;
}

// Description missing in models
message LinkPhysical {

  // Description missing in models
  LinkPhysicalBandwidth bandwidth = 1;

  // Description missing in models
  LinkPhysicalLatency latency = 2;
}

// A container for describing a link used between components.
message Link {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  optional string name = 1;

  // A description of the type of link.
  optional string description = 2;

  // A container for physical properties.
  LinkPhysical physical = 3;
}

// Description missing in models
message DeviceEndpoint {

  // An optional name of a device that contains the component.
  // If the property is empty the name of the device is the parent of the edge object.
  optional string device = 1;

  // The name of a component that exists in the containing device.
  // required = true
  optional string component = 2;
}

// Description missing in models
message InfrastructureEndpoint {

  // The name of a device that contains the component and MUST exist
  // in the infrastructure devices.
  // required = true
  optional string device = 1;

  // The name of a component that MUST exist in the containing device.
  // required = true
  optional string component = 2;
}

// Description missing in models
message InfrastructureEdge {

  // A device and component that is one endpoint of the edge
  // required = true
  InfrastructureEndpoint ep1 = 1;

  // A device and component that is the other endpoint of the edge
  // required = true
  InfrastructureEndpoint ep2 = 2;

  // If true every endpoint from ep1 will form an edge with every endpoint from ep2.
  // If false endpoints generated from ep1 and ep2 should be of the same length and
  // will be assigned together in the order they appear in each list.
  // required = true
  optional bool many2many = 3;

  // The name of a link that defines additional characteristics of the edge.
  // The name MUST exist in the links array of the infrastructure.
  // required = true
  optional string link = 4;
}

// Description missing in models
message DeviceEdge {

  // An optional device and component that is the other endpoint of the edge
  // required = true
  DeviceEndpoint ep1 = 1;

  // An optional device and component that is the other endpoint of the edge
  // required = true
  DeviceEndpoint ep2 = 2;

  // If true every endpoint from ep1 will form an edge with every endpoint from ep2.
  // If false endpoints generated from ep1 and ep2 should be of the same length and
  // will be assigned together in the order they appear in each list.
  // required = true
  optional bool many2many = 3;

  // The name of a link that defines additional characteristics of the edge.
  // The name MUST exist in the links array of the containing device.
  // required = true
  optional string link = 4;
}

// User defined data.
message AnnotationData {

  // Description missing in models
  optional string name = 1;
}

// Annotation allows for extending the base configuration with any type of
// additional information such as logical layouts, physical configuration etc.
// 
// This allows an organization to add their own data structures or
// open source data such as openconfig configuration messages which can be
// correlated to specific configuration endpoints.
message Annotation {

  // An alias for the annotation data.
  // required = true
  optional string name = 1;

  // The actual annotation data.
  // required = true
  AnnotationData data = 2;

  // A schema that describes the annotation data.
  optional string schema = 3;
}

// Error response generated while serving API request.
message Error {

  // Numeric status code based on the underlying transport being used.
  // The API server MUST set this code explicitly based on following references:
  // - HTTP 4xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.5
  // - HTTP 5xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.6
  // - gRPC errors: https://grpc.github.io/grpc/core/md_doc_statuscodes.html
  // required = true
  optional int32 code = 1;

  message Kind {
    enum Enum {
      unspecified = 0;
      validation = 1;
      internal = 2;
    }
  }
  // Classification of error originating from within API server that may not be mapped
  // to the value in `code`.
  // Absence of this field may indicate that the error did not originate from within API
  // server.
  optional Kind.Enum kind = 2;

  // List of error messages generated while executing the request.
  repeated string errors = 3;
}

// A list of warnings that have occurred while executing the request.
message Warning {

  // A list of any system specific warnings that have occurred while
  // executing the request.
  repeated string warnings = 1;
}

// The request has succeeded with no application content but the server
// may return a list of detailed warnings.
message Success {
  Warning warning = 1;
}

// The request did not succeed and server has responded with error details.
message Failure {
  Error error = 1;
}

// Data that needs to be streamed
message Data {
  uint64 chunk_size = 1;
  bytes datum = 2;
}

message SetGraphRequest {
  Infrastructure infrastructure = 1;
}
message SetGraphResponse {
  Warning warning = 1;
}


// Description missing in models
//
// For all RPCs defined in this service, API Server SHOULD provide JSON
// representation of `Error` message as an error string upon failure, ensuring
// name of enum constants (instead of value) for `kind` property is present
// in the representation
service Openapi {

  // Given an infrastructure payload this will create a complete infrastructure graph
  // that has been validated.
  rpc SetGraph(SetGraphRequest) returns (SetGraphResponse);
  // streaming version of the rpc SetGraph
  rpc streamSetGraph(stream Data) returns (SetGraphResponse);
}
